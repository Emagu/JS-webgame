<!DOCTYPE html>
<html>
<head>
     <script src="lib/jquery.js"></script>
    <script src="src/Item/Item.js"></script>
    <script src="src/Option.js"></script>
    <script src="../Server/game/js/ajax.js"></script>
</head>
<body></body>

<script>
        var GameArea,LeftControl,RightControl,TopControl;
        var Option,Turn=-1;
        var player=[],me;//放所有玩家和自己
        var AI=[];
        var FocalVar=1;//焦距 最低1
        var MapCube=[];//存放所有地形資訊
        var House=[];//放靜態物件的
        var TurnCube=[];//放倒數的事件
        var ActionCube=[];//動作方塊都放這
        var ViewCube=[];//放額外視野
        var needSend = 0;
        /*global UserData 實作於Data*/
        //var USER=new UserData();//用戶資料
        GameAreaInit();

        function GameAreaInit(){
            /*global PlayerItem 實作於View*/
            /*global OptionSet 實作於Option.js*/
            Option = new OptionSet();
            //document.body.style.width = Option.GameAreaWidth;
            //document.body.style.height = Option.GameAreaHeight;
            document.body.style.background="#000000";
            GameArea = document.createElement("div");
            //GameArea.style.width = "70%";
            //GameArea.style.height ="70%";
            GameArea.style.backgroundColor = "#000000";
            GameArea.style.margin = "0 auto";
            GameArea.style.position = 'absolute';
            GameArea.style.top = "0%";
            GameArea.style.left = "0%";
            document.body.appendChild(GameArea);
           //document.body.style.overflow = 'hidden';
            /*global Item 實作於Item.js*/
            for(var i=0;i<Option.CubeX;i++){
                MapCube.push([]);
                for(var j=0;j<Option.CubeY;j++){
                    /*global MapItem 實作於Item.js*/
                    //console.log(parent.VARIABLE.Game.Map);
                    var item = new MapItem(i,j,parent.VARIABLE.Game.Map[i*Option.CubeY+j].Type);
                    //x,y,type,Moveable,VisiAble
                    //var item = new MapItem(i,j,'Grass',true);//x,y,type,Moveable,VisiAble
                    MapCube[i].push(item);
                }
            }
            var tmp;
            for(var i=0;i!=parent.VARIABLE.Game.Item.length;i++)
            {
                if(i<parent.VARIABLE.Game.Item.length/2)
                    tmp=new PlayerItem(parent.VARIABLE.Game.Item[i].Postion.X,parent.VARIABLE.Game.Item[i].Postion.Y,parent.VARIABLE.Game.Item[i].ActorData.ActorID,"MAN","A");
                else
                    tmp=new PlayerItem(parent.VARIABLE.Game.Item[i].Postion.X,parent.VARIABLE.Game.Item[i].Postion.Y,parent.VARIABLE.Game.Item[i].ActorData.ActorID,"MAN","B");
                player.push(tmp);
                MapCube[tmp.X][tmp.Y].insert(tmp);
            }
            Start();
            getSynchronize();/*global getSynchronize in ajax*/
        }//遊戲畫面初始化
        
        function getSynchronize_res(){
            /*global request in ajax*/
            if (request.readyState == 4) {//完成狀態有好幾種，4代表資料傳回完成
                var data = request.responseText;//取得傳回的資料存在變數中
                console.log(data);
                if(data.match("error")==null) update(data);
                else console.log("error");
            }
        }//資料同步結果
        function sendGameCommand_res(){
            /*global request in ajax*/
            if (request.readyState == 4) {//完成狀態有好幾種，4代表資料傳回完成
                var data = request.responseText;//取得傳回的資料存在變數中
                console.log(data);
            }
        }//資料同步結果
        function update(data){
            /*
                        同步處理
                            .
                            .
                            .
            */
            /*繼續同步*/
            switch(needSend){
                case 1:
                    needSend = 0;
                    break;
                default:
                    getSynchronize();/*global getSynchronize in ajax*/
                    break;
            }
        }
        function Start(){
            ViewCube.length=0;
            //跑回合倒數執行的事件
            for(var i=0;i!=TurnCube.length;i++){
                switch (TurnCube[i].Type) {
                    case '空中偵察':
                        if(Turn>= TurnCube[i].Turn &&Turn<=TurnCube[i].EndTurn)
                        if(me.Side==TurnCube[i].Side)
                        {
                            ViewCube.push(TurnCube[i]);
                        }
                        break;
                }
            }
            //console.log(parent.VARIABLE.USER.ActorID);
            for(var i=0;i!=player.length;i++)
            if(parent.VARIABLE.USER.ActorID==player[i].No)
            {    
                me=player[i];
                console.log(me);
                if(Turn%player.length==i)
                    me.AP+=10;
                if(me.HP<=0)//HP
                {
                    Turn++;
                    Start();
                }
            }
            View();
            rendCube();
            window.scrollTo((me.X-10)* (Option.CubeSize + Option.CubeLine * 2) * FocalVar, (me.Y-5)* (Option.CubeSize + Option.CubeLine * 2) * FocalVar);
        }
        function Attack_Check(input){
            //然後他就死掉了
            if(input.HP<=0){
                if(input.VisiAble){
                setTimeout(function(){input.Div.style.opacity = "0.8";},300);
                setTimeout(function(){input.Div.style.opacity = "0.5";},500);
                setTimeout(function(){input.Div.style.opacity = "0.1";},1000);
 
                }
                setTimeout(function(){
                    
                    switch(input.Type){
                        case 'TIME_BOMB':
                            input.earse();
                            Area_Attack(3,input.X,input.Y);
                            break;
                    }
                    if(input.Class=='PlayerItem' || input.Class=='AiItem')
                    {
                        console.log(input);
                        input.earse();
                    }
                    View();
                    rendCube();
                },1200);
                
            }
        }
        function Skill(name,cost){
            //未來規劃都放在這裡，我決定通通分開寫啦!!jojo
            //蓋房子(沒有差異),
            //近戰,手榴彈(投擲類),火箭筒(直線攻擊類),迫擊砲(視野外轟炸)
            switch(name){
                case 'HOUSE':
                        Bulid('HOUSE');
                    break;
                case 'RADIO_POINT':
                        Bulid('RADIO_POINT');
                    break;
                case 'WATCH_POINT':
                        Bulid('WATCH_POINT');
                    break;
                case 'HEAL':
                        Bulid('HEAL');
                    break;
                case 'Melee':
                        Melee('Melee');
                    break;
                case 'Pelt':
                        Pelt();
                    break;
                case 'Mortar':
                        Mortar();
                    break;
                case 'Nuclear':
                        Nuclear('',100);
                    break;
                case 'RPG':
                    RPG();
                    break;
                case 'TIME_BOMB':
                    Bulid('TIME_BOMB');
                case '空中偵察':
                        Nuclear(name,5);
                    break;
                case '躲藏':
                        me.Hide();
                    break;
                case '現身':
                        me.Hide();
                    break;
                
            }
            rendCube();
        }
        function rendCube(){
            for(var i=0;i<Option.CubeX;i++){
                for(var j=0;j<Option.CubeY;j++){
                    if(MapCube[i][j].findTop().VisiAble)
                    {
                        MapCube[i][j].findTop().show();
                        MapCube[i][j].findTop().getinfo(MapCube[i][j].findTop());
                    }
                    if(MapCube[i][j].findTop().Under!=null)
                        GameArea.appendChild(MapCube[i][j].findTop().Under.Div);
                    GameArea.appendChild(MapCube[i][j].findTop().Div);
                }
            
            }//畫面描繪
            }
        function Radio(){
            var friends=[],index=0;
            if(me.HP>0)
            {    
                friends.push(me);
            }
            while(index<friends.length)
            {
                var connetRange=friends[index].RadioRange;
                var CenterX=friends[index].X,CenterY=friends[index].Y;
                for(var x=-connetRange;x<=connetRange;x++)
                {
                    var tmp=connetRange-Math.abs(x);
                    for(var y=-tmp;y<=tmp;y++)
                    {
                       if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定
                       if(MapCube[CenterX+x][CenterY+y].findTop()!=MapCube[CenterX+x][CenterY+y])//地圖上方有東西
                        {
                            if(MapCube[CenterX+x][CenterY+y].findTop().Side==me.Side)
                            {    
                                var check=true;
                                for(var i=0;i!=index+1;i++)
                                {
                                    if(MapCube[CenterX+x][CenterY+y].findTop()==friends[i])
                                        check=false;
                                }
                                if(check)
                                    friends.push(MapCube[CenterX+x][CenterY+y].findTop());
                            }
                        }
                    }
                }
                index++;
            }
            return friends;
        }
        function View(){
            //全關掉
            for(var i=0;i<Option.CubeX;i++){
                for(var j=0;j<Option.CubeY;j++){
                    MapCube[i][j].findTop().VisiAble=false;
                    MapCube[i][j].findTop().Div.style.backgroundImage = "";
                    MapCube[i][j].findTop().Div.style.backgroundColor = "#012345";
                }
            }
            var connetRange=me.RadioRange;//通訊測試範圍
            var friends=Radio();//可以另外取得物件視野
            for(var i=0;i!=ViewCube.length;i++){
                friends.push(ViewCube[i]);//額外視野
            }
            for(var i=0;i!=friends.length;i++)
            {
                CalHorizons(friends[i]);
            }
            //不同視野還沒寫
            function CalHorizons(friend)
            {
                var Horizons=friend.ViewRange;
                var CenterX=friend.X,CenterY=friend.Y;
                if(friend.Class=='PlayerItem'){//玩家會因地形不同而有視野限制
                    switch (MapCube[friend.X][friend.Y].Type)
                    {
                        case 'Forest'://森林
                                Horizons=3;
                            break;
                        case 'Mountain':
                                Horizons=3;
                            break;
                        case 'Sea':
                                Horizons=3;
                            break;
                    }
                }

                for(var x=-Horizons;x<=Horizons;x++)
                {
                    var tmp=Horizons-Math.abs(x);
                    for(var y=-tmp;y<=tmp;y++)
                    {
                        console.log(CenterX+x,CenterY+y);
                        if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定
                        {
                            console.log(MapCube[CenterX+x][CenterY+y]);
                            MapCube[CenterX+x][CenterY+y].VisiAble=true;
                            MapCube[CenterX+x][CenterY+y].findTop().VisiAble=true;
                        }        
                    }
                }
            }
        }
        function Move(){
            //按下移動按鈕後,先計算MoveRange來放MoveItem
            //在對MoveItem加功能，要刪掉只要把MoveCube清空就行
            //加入最短(AP)路徑計算，新增移動路徑顯示
            //未來可以加移動type如十字
            function Arms_Ability(x,y){
                var check;
                switch(me.Type){//兵種移動特性
                    case 'MAN':
                        if(x>=0 && x<Option.CubeX && y>=0 && y<Option.CubeY)//邊界判定 
                        if(MapCube[x][y].findTop().MoveAble==true) //地形不允許
                        if(MapCube[x][y].findTop().VisiAble)//超出視野
                           check=true;
                        else
                            check= false;
                        break;
                    default:
                        check= false;
                        
                }
                return check;
            }
            var CenterX = me.X;
            var CenterY = me.Y;
            var Horizons=me.MoveRange;
    
            for(var x=-Horizons;x<=Horizons;x++)
            {
                var tmp=Horizons-Math.abs(x);
               
                for(var y=-tmp;y<=tmp;y++)
                {
                    if(Arms_Ability(CenterX+x,CenterY+y))
                    {
                        var Move=new ActionItem(CenterX+x,CenterY+y);         
                        ActionCube.push(Move);
                        MapCube[CenterX+x][CenterY+y].insert(Move);
                        Move.Div.style.cursor='pointer';
                    }
                }
            }
            addEvent();
            rendCube();
            function addEvent(){
                for(var i=0;i!=ActionCube.length;i++){(function(){
                    var bestcost=-1;
                    var path=[],bestpath=[];
                    var tmp=ActionCube[i];
                function short_path(x,y,x1,y1,Ap){//找最短路徑
                    if(path.length<8){//收歛條件 很重要
                    var position=new Object();
                    position.x=x;
                    position.y=y;
                    if(x==x1&&y==y1)
                    {
                    if(bestcost<Ap)
                    {
                        bestpath.length=0;
                        bestcost=Ap;
                        for(var i=0;i!=path.length;i++)
                        {
                            bestpath.push(path[i]);
                        }
                        bestpath.push(position);
                    }
                }
                for(var i=0;i!=4;i++)//方向←↑→↓
                {
                    switch(i)
                    {
                    case 0:
                        if(x-1>=0 && x-1<Option.CubeX && y>=0 && y<Option.CubeY)//邊界判定 
                        if(MapCube[x-1][y].findTop().VisiAble && MapCube[x-1][y].findTop().MoveAble)
                        if(MapCube[x-1][y].findTop().Class=="ActionItem")
                        if(Ap-MapCube[x-1][y].findTop().Under.Move_AP>=0)
                        {
                            path.push(position);
                            short_path(x-1,y,x1,y1,Ap-MapCube[x-1][y].findTop().Under.Move_AP);
                            path.pop();
                        }
                        break;
                    case 1:
                        if(x>=0 && x<Option.CubeX && y-1>=0 && y-1<Option.CubeY)//邊界判定 
                        if(MapCube[x][y-1].findTop().VisiAble && MapCube[x][y-1].findTop().MoveAble)
                        if(MapCube[x][y-1].findTop().Class=="ActionItem")
                        if(Ap-MapCube[x][y-1].findTop().Under.Move_AP>=0 )
                        {
                            path.push(position);
                            short_path(x,y-1,x1,y1,Ap-MapCube[x][y-1].findTop().Under.Move_AP);
                            path.pop();
                        }
                        break;
                    case 2:
                        if(x+1>=0 && x+1<Option.CubeX && y>=0 && y<Option.CubeY)//邊界判定 
                        if(MapCube[x+1][y].findTop().VisiAble && MapCube[x+1][y].findTop().MoveAble)
                        if(MapCube[x+1][y].findTop().Class=="ActionItem")
                        if(Ap-MapCube[x+1][y].findTop().Under.Move_AP>=0 )
                        {
                            path.push(position);
                            short_path(x+1,y,x1,y1,Ap-MapCube[x+1][y].findTop().Under.Move_AP);
                            path.pop();
                        }
                        break;
                    case 3:
                        if(x>=0 && x<Option.CubeX && y+1>=0 && y+1<Option.CubeY)//邊界判定 
                        if(MapCube[x][y+1].findTop().VisiAble && MapCube[x][y+1].findTop().MoveAble)
                        if(MapCube[x][y+1].findTop().Class=="ActionItem")
                        if(Ap-MapCube[x][y+1].findTop().Under.Move_AP>=0 )
                        {
                                           path.push(position);
                            short_path(x,y+1,x1,y1,Ap-MapCube[x][y+1].findTop().Under.Move_AP);
                            path.pop();
                        }
                        break;
                    }
                }
                    }
            }
                    //滑鼠進入、離開顯示
                    tmp.Div.addEventListener('mouseover',function() {
                         for(var j=0;j!=ActionCube.length;j++){
                           ActionCube[j].show();
                        }
                        //路徑顯示
              
                        short_path(me.X,me.Y,tmp.X,tmp.Y,me.AP);
                        if(bestcost>=0)
                        for(var j=0;j!=bestpath.length;j++)
                        {
                            if(MapCube[bestpath[j].x][bestpath[j].y].findTop().Class=='ActionItem'){
                                //MapCube[bestpath[j].x][bestpath[j].y].findTop().Div.style.backgroundColor='#FF0000';
                                if(MapCube[bestpath[j].x][bestpath[j].y].findTop().Under.Class!='MapItem')
                                    MapCube[bestpath[j].x][bestpath[j].y].findTop().Under.Div.style.backgroundColor='#FF0000';
                                else
                                    MapCube[bestpath[j].x][bestpath[j].y].findTop().Div.style.backgroundColor='#FF0000';
                            }
                        
                        }
                        while(parent.VARIABLE.View.GameArea.RightControl.button.firstChild) parent.VARIABLE.View.GameArea.RightControl.button.removeChild(parent.VARIABLE.View.GameArea.RightControl.button.firstChild);
                        if(bestcost>=0){
                        parent.VARIABLE.View.GameArea.RightControl.button.appendChild(document.createTextNode("從座標:"+me.X+","+me.Y));
                        parent.VARIABLE.View.GameArea.RightControl.button.appendChild(document.createElement("br"));
                        parent.VARIABLE.View.GameArea.RightControl.button.appendChild(document.createTextNode("移動到座標:"+tmp.X+","+tmp.Y));
                        parent.VARIABLE.View.GameArea.RightControl.button.appendChild(document.createElement("br"));
                        parent.VARIABLE.View.GameArea.RightControl.button.appendChild(document.createTextNode("所需AP:"+(me.AP-bestcost)+"點"));
                        }
                        else
                        parent.VARIABLE.View.GameArea.RightControl.button.appendChild(document.createTextNode("AP點不足"));
                        parent.VARIABLE.View.GameArea.RightControl.button.appendChild(document.createElement("br"));
                        
                    });
                    
                    tmp.Div.addEventListener('click',function(){
                    if(bestcost>=0){
                    for(var j=0;j!=ActionCube.length;j++){
                        ActionCube[j].earse();
                    }
                    MapCube[me.X][me.Y].earse(me);
                    me.Move(tmp.X,tmp.Y);
                    //要新增可以躲藏、穿越建築物
                    if(MapCube[tmp.X][tmp.Y].findTop().Type=="HOUSE"){
                         MapCube[tmp.X][tmp.Y].insert(me,MapCube[tmp.X][tmp.Y].findTop());
                    }
                    else
                        MapCube[tmp.X][tmp.Y].insert(me);
                    me.AP=bestcost;
                    ActionCube.length=0;
                    rendCube();
                    parent.VARIABLE.View.GameArea.LeftControl.MoveButton.childNodes[0].nodeValue="開始移動";
                    }
                    });
                    
            }());}}
        }
        function ActionCancel(){
            for(var i=0;i!=ActionCube.length;i++){
                ActionCube[i].earse();
            }
            ActionCube.length=0;
            rendCube();
        }
        function Area_Attack(Horizons,CenterX,CenterY,ATK){
            //爆炸放這裡!!
            for(var x=-Horizons;x<=Horizons;x++)
                {
                    var _tmp=Horizons-Math.abs(x);
                    for(var y=-_tmp;y<=_tmp;y++)
                    {
                        if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                        if(MapCube[CenterX+x][CenterY+y].findTop().Invincible==false)
                        {
                            
                            MapCube[CenterX+x][CenterY+y].findTop().HP-=100;
                            Attack_Check(MapCube[CenterX+x][CenterY+y].findTop());
                        }
                    }
                    }
            }
        //我不知道要怎麼取,雖然名字都是武器,但其實是顯示範圍的差異
        function Bulid(input){
            var CenterX = me.X;
            var CenterY = me.Y;
            var Horizons=1;
            for(var x=-Horizons;x<=Horizons;x++)
            {
                for(var y=-Horizons;y<=Horizons;y++)
                {
                    if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                    if(MapCube[CenterX+x][CenterY+y].findTop().MoveAble==true) //地形不允許
                    if(MapCube[CenterX+x][CenterY+y].findTop().VisiAble)//超出視野
                    if(MapCube[CenterX+x][CenterY+y].findTop().Class=='MapItem')//只能蓋在地圖上
                    {
                        var tmp=new ActionItem(CenterX+x,CenterY+y);
                        ActionCube.push(tmp);
                        MapCube[CenterX+x][CenterY+y].insert(tmp);
                        tmp.Div.style.cursor='pointer';
                    }
                }
            }
            addEvent(input);
            rendCube();
            function addEvent(input){
                for(var i=0;i!=ActionCube.length;i++){(function(){
                    var tmp=ActionCube[i];
                    //滑鼠進入、離開顯示
                    tmp.Div.addEventListener('mouseover',function() {
                         for(var j=0;j!=ActionCube.length;j++){
                            ActionCube[j].show();
                        }
                        if(tmp.Under.Class!='MapItem')
                        {
                            tmp.Under.Div.style.backgroundColor='#FF0000';
                        }
                        else
                            tmp.Div.style.backgroundColor='#FF0000';
                    });
                    
                    tmp.Div.addEventListener('click',function(){
                    //要蓋的東西不同放這裡
                    for(var j=0;j!=ActionCube.length;j++){
                        ActionCube[j].earse();
                    }
                    var buliding=new BulidingItem(tmp.X,tmp.Y,input,me.Side,Turn);
                    House.push(buliding);
                    MapCube[tmp.X][tmp.Y].insert(buliding);
                    ActionCube.length=0;
                    rendCube();
                    parent.VARIABLE.View.GameArea.LeftControl.BulidButton.childNodes[0].nodeValue="蓋房子!!";
                    });
                    
            }());}}
        }
        function Melee(input){
            //近戰攻擊放這裡，input放武器
            var CenterX = me.X;
            var CenterY = me.Y;
            var Horizons=1;
            for(var x=-Horizons;x<=Horizons;x++)
            {
                for(var y=-Horizons;y<=Horizons;y++)
                {
                    if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                    if(MapCube[CenterX+x][CenterY+y].findTop().VisiAble)//超出視野
                    {
                        var Attack=new ActionItem(CenterX+x,CenterY+y);
                        ActionCube.push(Attack);
                        MapCube[CenterX+x][CenterY+y].insert(Attack);
                        Attack.Div.style.cursor='pointer';
                        
                    }
                }
            }
            addEvent(input);
            rendCube();
            function addEvent(input){//要使用迴圈加eventlistener要這樣寫
                for(var i=0;i!=ActionCube.length;i++){
                (function(){
                var tmp=ActionCube[i];
                  tmp.Div.addEventListener('mouseover',function() {
                      for(var j=0;j!=ActionCube.length;j++){
                           ActionCube[j].show();
                     }
                     
                     if(tmp.Under.Class!='MapItem' && tmp.Under.VisiAble)
                     {
                         tmp.Under.Div.style.backgroundColor='#FF0000';
                     }
                     else
                     tmp.Div.style.backgroundColor='#FF0000';
                    });
                    tmp.Div.addEventListener('click',function(){
                    //武器差異放這裡改
                    MapCube[tmp.X][tmp.Y].findTop().earse();
                    switch(input){
                        case 'Melee':
                            if(MapCube[tmp.X][tmp.Y].findTop().Invincible==false){
                                MapCube[tmp.X][tmp.Y].findTop().HP-=50;;
                                Attack_Check(MapCube[tmp.X][tmp.Y].findTop());
                            }
                            break;
                    }
                    
                    for(var j=0;j!=ActionCube.length;j++)
                        ActionCube[j].earse();
                    ActionCube.length=0;
                    
                    //rendCube();
                    parent.VARIABLE.View.GameArea.LeftControl.AttackButton.childNodes[0].nodeValue="開始攻擊"; },false);
                }());
                
            }
            }
        }
        function Pelt(input){
            //投擲類武器放這，不會超出視野範圍
            var CenterX = me.X;
            var CenterY = me.Y;
            var Horizons=me.ViewRange;//攻擊距離顯示範圍大小
            for(var x=-Horizons;x<=Horizons;x++)
            {
                var tmp=Horizons-Math.abs(x);
                for(var y=-tmp;y<=tmp;y++)
                {
                    if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                    {
                        var Attack=new ActionItem(CenterX+x,CenterY+y);
                        ActionCube.push(Attack);
                        MapCube[CenterX+x][CenterY+y].insert(Attack);
                        Attack.Div.style.cursor='pointer';
                        
                    }
                }
            }
            Horizons=1;//攻擊的範圍大小
            addEvent(input);
            rendCube();
            function addEvent(input){//要使用迴圈加eventlistener要這樣寫
                for(var i=0;i!=ActionCube.length;i++){
                (function(){
                var tmp=ActionCube[i];
                var CenterX = tmp.X;
                var CenterY = tmp.Y;
                
                  tmp.Div.addEventListener('mouseover',function() {
                      for(var j=0;j!=ActionCube.length;j++){
                           ActionCube[j].show();     
                        }
                      
                    for(var x=-Horizons;x<=Horizons;x++)
                    {
                        var _tmp=Horizons-Math.abs(x);
               
                        for(var y=-_tmp;y<=_tmp;y++)
                        {
                            if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                            if(MapCube[CenterX+x][CenterY+y].findTop().Class=='ActionItem')
                            {
                                 if(MapCube[CenterX+x][CenterY+y].findTop().Under.Class!='MapItem' && MapCube[CenterX+x][CenterY+y].findTop().Under.VisiAble)
                                    MapCube[CenterX+x][CenterY+y].findTop().Under.Div.style.backgroundColor='#FF0000';
                                else
                                    MapCube[CenterX+x][CenterY+y].findTop().Div.style.backgroundColor='#FF0000';
                            }
                        }
                    }});
                    tmp.Div.addEventListener('click',function(){
                    //武器差異放這裡改
                    
                    
                    for(var j=0;j!=ActionCube.length;j++)
                        ActionCube[j].earse();
                    Area_Attack(1,tmp.X,tmp.Y);
                    ActionCube.length=0;
                    View();
                    rendCube();
                    parent.VARIABLE.View.GameArea.LeftControl.AttackButton.childNodes[0].nodeValue="開始攻擊"; },false);
                }());
                
            }
            }
        }
        function Mortar(input){
            //迫擊砲類武器放這，會超出視野範圍然後太近不能用
            var CenterX = me.X;
            var CenterY = me.Y;
            var Horizons=15;//攻擊距離顯示範圍大小
            for(var x=-Horizons;x<=Horizons;x++)
            {
                var tmp=Horizons-Math.abs(x);
                for(var y=-tmp;y<=tmp;y++)
                {
                    if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                    if(Math.abs(x)+Math.abs(y)>5)//近距離不能用
                    {
                        var Attack=new ActionItem(CenterX+x,CenterY+y);
                        ActionCube.push(Attack);
                        MapCube[CenterX+x][CenterY+y].insert(Attack);
                        Attack.Div.style.cursor='pointer';
                        
                    }
                }
            }
            addEvent();
            rendCube();
            
            function addEvent(){//要使用迴圈加eventlistener要這樣寫
                for(var i=0;i!=ActionCube.length;i++){
                (function(){
                Horizons=2;
                var tmp=ActionCube[i];
                var CenterX = tmp.X;
                var CenterY = tmp.Y;
                
                  tmp.Div.addEventListener('mouseover',function() {
                      for(var j=0;j!=ActionCube.length;j++){
                           ActionCube[j].show();     
                        }
                      
                    for(var x=-Horizons;x<=Horizons;x++)
                    {
                        var _tmp=Horizons-Math.abs(x);
               
                        for(var y=-_tmp;y<=_tmp;y++)
                        {
                            if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                            if(MapCube[CenterX+x][CenterY+y].findTop().Class=='ActionItem')
                            {
                                if(MapCube[CenterX+x][CenterY+y].findTop().Under.Class!='MapItem' && MapCube[CenterX+x][CenterY+y].findTop().Under.VisiAble)
                                    MapCube[CenterX+x][CenterY+y].findTop().Under.Div.style.backgroundColor='#FF0000';
                                else
                                    MapCube[CenterX+x][CenterY+y].findTop().Div.style.backgroundColor='#FF0000';
                                  
                            }
                        }
                    }});
                    tmp.Div.addEventListener('click',function(){
                    //武器差異放這裡改
                    
                    for(var j=0;j!=ActionCube.length;j++)
                        ActionCube[j].earse();
                    ActionCube.length=0;
                    Area_Attack(2,tmp.X,tmp.Y);
                    View();
                    rendCube();
                    parent.VARIABLE.View.GameArea.LeftControl.AttackButton.childNodes[0].nodeValue="開始攻擊"; },false);
                }());
                
            }
            }
        }
        function RPG(input){
            //RPG武器放這，會超出視野範圍然後太近不能用
            var CenterX = me.X;
            var CenterY = me.Y;
            var Horizons=15;//攻擊距離顯示範圍大小
            for(var x=-Horizons;x<=Horizons;x++)
            {
                var tmp=Horizons-Math.abs(x);
                for(var y=-tmp;y<=tmp;y++)
                {
                    if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                    if((x==0 &&  y!=0)||(x!=0 &&  y==0))
                    {
                        var Attack=new ActionItem(CenterX+x,CenterY+y);
                        ActionCube.push(Attack);
                        MapCube[CenterX+x][CenterY+y].insert(Attack);
                        Attack.Div.style.cursor='pointer';
                        
                    }
                }
            }
            
            addEvent(input);
            rendCube();
            function addEvent(input){//要使用迴圈加eventlistener要這樣寫
                for(var i=0;i!=ActionCube.length;i++){
                (function(){
                var tmp=ActionCube[i];
                
                
                 tmp.Div.addEventListener('mouseover',function() {
                    for(var j=0;j!=ActionCube.length;j++){
                       ActionCube[j].show();     
                        }
                    
                    for(var j=0;j!=ActionCube.length;j++){
                        if(tmp.X>me.X)
                        if(ActionCube[j].X>me.X)
                            if(ActionCube[j].Under.Class!='MapItem' && ActionCube[j].Under.VisiAble)
                                ActionCube[j].Under.Div.style.backgroundColor="#FF0000";
                            else
                                ActionCube[j].Div.style.backgroundColor="#FF0000";
                            
                        if(tmp.X<me.X)
                        if(ActionCube[j].X<me.X)
                            if(ActionCube[j].Under.Class!='MapItem'&& ActionCube[j].Under.VisiAble)
                                ActionCube[j].Under.Div.style.backgroundColor="#FF0000";
                            else
                                ActionCube[j].Div.style.backgroundColor="#FF0000";
                        
                        if(tmp.Y>me.Y)
                        if(ActionCube[j].Y>me.Y)
                            if(ActionCube[j].Under.Class!='MapItem'&& ActionCube[j].Under.VisiAble)
                                ActionCube[j].Under.Div.style.backgroundColor="#FF0000";
                            else
                                ActionCube[j].Div.style.backgroundColor="#FF0000";
                        
                        if(tmp.Y<me.Y)
                        if(ActionCube[j].Y<me.Y)
                            if(ActionCube[j].Under.Class!='MapItem'&& ActionCube[j].Under.VisiAble)
                                ActionCube[j].Under.Div.style.backgroundColor="#FF0000";
                            else
                                ActionCube[j].Div.style.backgroundColor="#FF0000";
                    }
                    });
                    tmp.Div.addEventListener('click',function(){
                    //武器差異放這裡改
                    
                    if(tmp.X>me.X)
                    {
                        for(var j=0;j!=ActionCube.length;j++){
                            if(ActionCube[j].X>me.X)
                            if(MapCube[ActionCube[j].X][ActionCube[j].Y].Top.Class!='ActionItem')
                            {
                                Area_Attack(1,ActionCube[j].X,ActionCube[j].Y);
                                break;
                            }
                        }
                    }
                    if(tmp.X<me.X)
                    {
                        for(var j=ActionCube.length-1;j!=0;j--){
                            if(MapCube[ActionCube[j].X][ActionCube[j].Y].Top.Class!='ActionItem')
                            if(ActionCube[j].X<me.X)
                            {
                                Area_Attack(1,ActionCube[j].X,ActionCube[j].Y);
                                break;
                            }
                        }
                    }
                    if(tmp.Y<me.Y)
                    {
                        for(var j=ActionCube.length-1;j!=0;j--){
                            if(MapCube[ActionCube[j].X][ActionCube[j].Y].Top.Class!='ActionItem')
                            if(ActionCube[j].Y<me.Y)
                            {
                                Area_Attack(1,ActionCube[j].X,ActionCube[j].Y);
                                break;
                            }
                        }
                    }
                    if(tmp.Y>me.Y)
                    {
                        for(var j=0;j!=ActionCube.length;j++){
                            if(MapCube[ActionCube[j].X][ActionCube[j].Y].Top.Class!='ActionItem')
                            if(ActionCube[j].Y>me.Y)
                            {
                                Area_Attack(1,ActionCube[j].X,ActionCube[j].Y);
                                break;
                            }
                        }
                    }
                    for(var j=0;j!=ActionCube.length;j++)
                        ActionCube[j].earse();
                    ActionCube.length=0;
    
                    View();
                    rendCube();
                    parent.VARIABLE.View.GameArea.LeftControl.AttackButton.childNodes[0].nodeValue="開始攻擊"; },false);
                }());
                
            }
            }
        }
        function Nuclear(input,H){
            var CenterX = me.X;
            var CenterY = me.Y;
            var Horizons=100;//攻擊距離顯示範圍大小
            for(var x=-Horizons;x<=Horizons;x++)
            {
                var tmp=Horizons-Math.abs(x);
                for(var y=-tmp;y<=tmp;y++)
                {
                    if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                    {
                        var Attack=new ActionItem(CenterX+x,CenterY+y);
                        ActionCube.push(Attack);
                        MapCube[CenterX+x][CenterY+y].insert(Attack);
                        Attack.Div.style.cursor='pointer';
                        
                    }
                }
            }
            addEvent(input,H);
            View();
            rendCube();
            function addEvent(input,H){//要使用迴圈加eventlistener要這樣寫
                for(var i=0;i!=ActionCube.length;i++){
                (function(){
                var tmp=ActionCube[i];
                var CenterX = tmp.X;
                var CenterY = tmp.Y;
                var Horizons=H;
                  tmp.Div.addEventListener('mouseover',function() {
                      for(var j=0;j!=ActionCube.length;j++){
                           ActionCube[j].show();     
                        }
                      
                    for(var x=-Horizons;x<=Horizons;x++)
                    {
                        var _tmp=Horizons-Math.abs(x);
               
                        for(var y=-_tmp;y<=_tmp;y++)
                        {
                            if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                            if(MapCube[CenterX+x][CenterY+y].findTop().Class=='ActionItem')
                            {
                                  MapCube[CenterX+x][CenterY+y].findTop().Div.style.backgroundColor='#FF0000';
                            }
                        }
                    }});
                    tmp.Div.addEventListener('click',function(){
                    //武器差異放這裡改
                    switch (input) {
                        case '空中偵察':
                            var turn_tmp= new TurnItem(tmp.X,tmp.Y,input,me.Side,Turn);
                                TurnCube.push(turn_tmp);
                            break;
                        
                        default:
                            Area_Attack(100,tmp.X,tmp.Y);
                    }
                    
                    for(var j=0;j!=ActionCube.length;j++)
                        ActionCube[j].earse();
                    ActionCube.length=0;
                    View();
                    rendCube();
                    parent.VARIABLE.View.GameArea.LeftControl.AttackButton.childNodes[0].nodeValue="開始攻擊"; },false);
                }());
                
            }
            }
        }
        function AI_Action(){
            var bestcost=-1,bestdis=99;
            var path=[],bestpath=[];
            function short_path(x,y,x1,y1,Ap){//找最短路徑
                if(path.length<8){//收歛條件 很重要
                        var position=new Object();
                        position.x=x;
                        position.y=y;
                        var dis=Math.sqrt(Math.pow(x-x1,2)+Math.pow(y-y1,2));
                    if(dis<bestdis)
                    {
                        bestdis=dis;
                        bestpath.length=0;
                        bestcost=Ap;
                        for(var i=0;i!=path.length;i++)
                        {
                            bestpath.push(path[i]);
                        }
                        bestpath.push(position);
                    
                    }
                for(var i=0;i!=4;i++)//方向←↑→↓
                {
                    switch(i)
                    {
                    case 0:
                        if(x-1>=0 && x-1<Option.CubeX && y>=0 && y<Option.CubeY)//邊界判定 
                        if(MapCube[x-1][y].findTop().MoveAble)
                        if(Ap-MapCube[x-1][y].findTop().Move_AP>=0)
                        {
                            path.push(position);
                            short_path(x-1,y,x1,y1,Ap-MapCube[x-1][y].findTop().Move_AP);
                            path.pop();
                        }
                        break;
                    case 1:
                        if(x>=0 && x<Option.CubeX && y-1>=0 && y-1<Option.CubeY)//邊界判定 
                        if(MapCube[x][y-1].findTop().MoveAble)
                        if(Ap-MapCube[x][y-1].findTop().Move_AP>=0 )
                        {
                            path.push(position);
                            short_path(x,y-1,x1,y1,Ap-MapCube[x][y-1].findTop().Move_AP);
                            path.pop();
                        }
                        break;
                    case 2:
                        if(x+1>=0 && x+1<Option.CubeX && y>=0 && y<Option.CubeY)//邊界判定 
                        if(MapCube[x+1][y].findTop().MoveAble)
                        if(Ap-MapCube[x+1][y].findTop().Move_AP>=0 )
                        {
                            path.push(position);
                            short_path(x+1,y,x1,y1,Ap-MapCube[x+1][y].findTop().Move_AP);
                            path.pop();
                        }
                        break;
                    case 3:
                        if(x>=0 && x<Option.CubeX && y+1>=0 && y+1<Option.CubeY)//邊界判定 
                        if(MapCube[x][y+1].findTop().MoveAble)
                        if(Ap-MapCube[x][y+1].findTop().Move_AP>=0 )
                        {
                            path.push(position);
                            short_path(x,y+1,x1,y1,Ap-MapCube[x][y+1].findTop().Move_AP);
                            path.pop();
                        }
                        break;
                        }
                    }
                    }
                }
            short_path(AI[0].X,AI[0].Y,player[0].X,player[0].Y,AI[0].AP);

            Start();
        }
        function Paint(input){
            var CenterX = 0;
            var CenterY = 0;
            var Horizons=100;
            for(var x=-Horizons;x<=Horizons;x++)
            {
                var tmp=Horizons-Math.abs(x);
               
                for(var y=-tmp;y<=tmp;y++)
                {
                    if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                    {
                        var Attack=new ActionItem(CenterX+x,CenterY+y);
                        ActionCube.push(Attack);
                        MapCube[CenterX+x][CenterY+y].insert(Attack);
                        Attack.Div.style.cursor='pointer';
                        
                    }
                }
            }
            Horizons=0;//要擴散多大,0為1個
            addEvent(input);
            rendCube();
            function addEvent(input){//要使用迴圈加eventlistener要這樣寫
                //擴散攻擊測試,
                for(var i=0;i!=ActionCube.length;i++){
                (function(){
                var tmp=ActionCube[i];
                var CenterX = tmp.X;
                var CenterY = tmp.Y;
                
                
                tmp.Div.addEventListener('dblclick',function() {
                    Horizons++;
                });
                  tmp.Div.addEventListener('mouseover',function() {
                      for(var j=0;j!=AttackCube.length;j++){
                            ActionCube[j].Div.style.backgroundColor="transparent";
                            }        
                        
                      
                    for(var x=-Horizons;x<=Horizons;x++)
                    {
                        var _tmp=Horizons-Math.abs(x);
               
                        for(var y=-_tmp;y<=_tmp;y++)
                        {
                            if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                            if(MapCube[CenterX+x][CenterY+y].findTop().Class=='AttackItem')
                            {
                                  MapCube[CenterX+x][CenterY+y].findTop().Div.style.backgroundColor='#FF0000';
                            }
                        }
                    }});
                    tmp.Div.addEventListener('click',function(){
                    
                    for(var x=-Horizons;x<=Horizons;x++)
                    {
                        var _tmp=Horizons-Math.abs(x);
               
                        for(var y=-_tmp;y<=_tmp;y++)
                        {
                            if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                            if(MapCube[CenterX+x][CenterY+y].findTop().Class=='ActionItem')
                            {
                                MapCube[CenterX+x][CenterY+y].Type=input;
                            }
                        }
                    }
                    
                    //rendCube();
                    },false);
                }());
                
            }
            }
        }
        function Stay() {
            parent.resetButton();
            
            //UpLoad();
            //踩到甚麼放這裡
            var tmp=me.Top;
            while(tmp!=null){
                switch (tmp.Type) {
                    case 'HEAL':
                        MapCube[me.X][me.Y].earse(tmp);
                    break;
                }
                tmp=tmp.Top;
            }
            View();
            rendCube();
            Start();
        }
        function UpLoad(){
            var updata = new Object();
            updata.House = [];
            updata.Player = [];
            for(var i=0;i!=House.length;i++)
            {
                updata.House.push(House[i].getData());
            }
            for(var i=0;i!=player.length;i++)
            {
                updata.Player.push(player[i].getData());
            }
            
            var data=JSON.stringify(updata);
            //saveTextAsFile('Map',data);//下載Map
           //最後在json
            /*global sendGameCommand 實作於ajax*/
            sendGameCommand(JSON.stringify(updata));
        }//上傳資料
        
        function saveTextAsFile( _fileName, _text ) {
            var textFileAsBlob = new Blob([_text], {type:'text/plain'});
 
            var downloadLink = document.createElement("a");
            downloadLink.download = _fileName;
            downloadLink.innerHTML = "Download File";
            if (window.webkitURL != null) {
            // Chrome allows the link to be clicked
            // without actually adding it to the DOM.
                downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
            } else {
          // Firefox requires the link to be added to the DOM
             // before it can be clicked.
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.onclick = destroyClickedElement;
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
         }
 
        downloadLink.click();
        }
        function destroyClickedElement(event) {
            document.body.removeChild(event.target);
        }
</script>


</html>
