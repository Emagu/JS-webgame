<!DOCTYPE html>
<html>
<head>
     <script src="lib/jquery.js"></script>
    <script src="src/Item/Item.js"></script>
    <script src="src/Option.js"></script>
    <script src="../Server/js/ajax.js"></script>
</head>
<body></body>


<script>
        var GameArea,LeftControl,RightControl,TopControl;
        var Option,Turn=0;
        var player=[],me;//放所有玩家和自己
        var FocalVar=1;//焦距 最低1
        var MapCube=[];//存放所有地形資訊
        var House=[];//放房子的
        var Drop=[];//放掉落物的(補包)
        var BulidCube=[];//顯示建築方塊範圍
        var MoveCube=[];//放移動方塊
        var AttackCube=[];//放攻擊方塊
        /*global UserData 實作於Data*/
        //var USER=new UserData();//用戶資料
        GameAreaInit();

        function GameAreaInit(){
            /*global PlayerItem 實作於View*/
            /*global OptionSet 實作於Option.js*/
            Option = new OptionSet();
            //document.body.style.width = Option.GameAreaWidth;
            //document.body.style.height = Option.GameAreaHeight;
            document.body.style.background="#000000";
            GameArea = document.createElement("div");
            //GameArea.style.width = "70%";
            //GameArea.style.height ="70%";
            GameArea.style.backgroundColor = "#000000";
            GameArea.style.margin = "0 auto";
            GameArea.style.position = 'absolute';
            
            GameArea.style.top = "0%";
            GameArea.style.left = "0%";
           document.body.appendChild(GameArea);
           //document.body.style.overflow = 'hidden';
            /*global Item 實作於Item.js*/
            for(var i=0;i<Option.CubeX;i++){
                MapCube.push([]);
                for(var j=0;j<Option.CubeY;j++){
                    /*global MapItem 實作於Item.js*/
                    var item = new MapItem(i,j,'Grass');//x,y,type,Moveable,VisiAble
                    MapCube[i].push(item);
                }
            }
           // var tmp=new PlayerItem(50,10,1,'MAN','A'); //直接宣告在這邊 ajax直接送過來
            //player.push(tmp);
            //MapCube[50][10].insert(player[0]);
            //me=player[0];
            //View();
            rendCube();
        }//遊戲畫面初始化
        function Synchronize_res(){
            /*global request 實作於 ajax.js*/
            if (request.readyState == 4) {//完成狀態有好幾種，4代表資料傳回完成
                var data = request.responseText;//取得傳回的資料存在變數中
        		data = JSON.parse(data);
        		console.log(data);
            }
        }//資料同步結果
        function rendCube(){
            for(var i=0;i<Option.CubeX;i++){
                for(var j=0;j<Option.CubeY;j++){
                    if(MapCube[i][j].findTop().VisiAble==true)
                    {
                        switch (MapCube[i][j].findTop().Class) {
                            case 'MapItem':
                                MapCube[i][j].findTop().setType();
                                break;
                            case 'PlayerItem':
                                MapCube[i][j].findTop().Div.style.backgroundColor = "#FF0000";
                                break;
                            case 'DropItem':
                                MapCube[i][j].findTop().Div.style.backgroundColor = "#112F01";
                                break;
                            case 'BulidingItem':
                                MapCube[i][j].findTop().Div.style.backgroundColor = "#FF00FF";
                                break;
                            case 'BulidItem':
                                if(MapCube[i][j].findTop().Under.Class=='MapItem')
                                    MapCube[i][j].findTop().Div.style.backgroundColor = "#FFFF00";
                                else
                                    MapCube[i][j].findTop().Div.style.backgroundColor = MapCube[i][j].findTop().Under.Div.style.backgroundColor;
                                break;
                                break;
                            case'MoveItem':
                                 if(MapCube[i][j].findTop().Under.Class=='MapItem')
                                    MapCube[i][j].findTop().Div.style.backgroundColor = "#FFFF00";
                                else
                                    MapCube[i][j].findTop().Div.style.backgroundColor = MapCube[i][j].findTop().Under.Div.style.backgroundColor;
                                break;
                            case 'AttackItem'://未畫圖而改
                                //if(MapCube[i][j].findTop().Under.Class=='MapItem')
                                //    MapCube[i][j].findTop().Div.style.backgroundColor = "#FFFF00";
                                //else
                                //    MapCube[i][j].findTop().Div.style.backgroundColor = MapCube[i][j].findTop().Under.Div.style.backgroundColor;
                                 MapCube[i][j].setType();
                                 MapCube[i][j].findTop().Div.style.backgroundColor = MapCube[i][j].Div.style.backgroundColor;
                                break;
                            default:
                                // code
                        }
                        MapCube[i][j].findTop().getinfo(MapCube[i][j].findTop());
                    }
                    else
                    {
                       MapCube[i][j].findTop().Div.style.backgroundColor = "#012345";//for TEST
                    }
                    GameArea.appendChild(MapCube[i][j].findTop().Div);
                }
            
            }//畫面描繪
            //window.scrollTo((me.X-10)* (Option.CubeSize + Option.CubeLine * 2) * FocalVar, (me.Y-5)* (Option.CubeSize + Option.CubeLine * 2) * FocalVar);
            }
        function Radio(){
            var friends=[],index=0;
            friends.push(me);
            while(index<friends.length)
            {
                var connetRange=friends[index].RadioRange;
                var CenterX=friends[index].X,CenterY=friends[index].Y;
                for(var x=-connetRange;x<=connetRange;x++)
                {
                    var tmp=connetRange-Math.abs(x);
                    for(var y=-tmp;y<=tmp;y++)
                    {
                       if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定
                       if(MapCube[CenterX+x][CenterY+y].findTop()!=MapCube[CenterX+x][CenterY+y])//地圖上方有東西
                        {
                            if(MapCube[CenterX+x][CenterY+y].findTop().Side==me.Side)
                            {    
                                var check=true;
                                for(var i=0;i!=index+1;i++)
                                {
                                    if(MapCube[CenterX+x][CenterY+y].findTop()==friends[i])
                                        check=false;
                                }
                                if(check)
                                    friends.push(MapCube[CenterX+x][CenterY+y].findTop());
                            }
                        }
                    }
                }
                index++;
            }
            return friends;
        }
        function View(){
            //全關掉
            for(var i=0;i<Option.CubeX;i++){
                for(var j=0;j<Option.CubeY;j++){
                   MapCube[i][j].findTop().VisiAble=false;
                }
            }
            var connetRange=me.RadioRange;//通訊測試範圍
            var friends=Radio();
            for(var i=0;i!=friends.length;i++)
            {
                CalHorizons(friends[i]);
            }
            
            function CalHorizons(friend)
            {
                var Horizons=friend.ViewRange;
                var CenterX=friend.X,CenterY=friend.Y;
                
                for(var x=-Horizons;x<=Horizons;x++)
                {
                    var tmp=Horizons-Math.abs(x);
                    for(var y=-tmp;y<=tmp;y++)
                    {
                        if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定
                        {
                            MapCube[CenterX+x][CenterY+y].VisiAble=true;
                           
                            if(MapCube[CenterX+x][CenterY+y].findTop().Class!='MapItem')
                            {    
                                MapCube[CenterX+x][CenterY+y].findTop().VisiAble=true;
                            }
                        }        
                    }
                }
            }
        }
        function Move(){
            //按下移動按鈕後,先計算MoveRange來放MoveItem
            //在對MoveItem加功能，要刪掉只要把MoveCube清空就行
            //加入最短(AP)路徑計算，新增移動路徑顯示
            //未來可以加移動type如十字
            function addEvent(){
                for(var i=0;i!=MoveCube.length;i++){(function(){
                    var bestcost=-1;
                    var path=[],bestpath=[];
                    var tmp=MoveCube[i];
                    function short_path(x,y,x1,y1,Ap){//找最短路徑
                    if(me.AP-Ap<=30 && path.length<10){//收歛條件 很重要
                    var position=new Object();
                    position.x=x;
                    position.y=y;
                    if(x==x1&&y==y1)
                    {
                    if(bestcost<Ap)
                    {
                        bestpath.length=0;
                        bestcost=Ap;
                        for(var i=0;i!=path.length;i++)
                        {
                            bestpath.push(path[i]);
                        }
                        bestpath.push(position);
                    }
                }
                for(var i=0;i!=4;i++)//方向←↑→↓
                {
                    switch(i)
                    {
                    case 0:
                        if(x-1>=0 && x-1<Option.CubeX && y>=0 && y<Option.CubeY)//邊界判定 
                        if(MapCube[x-1][y].findTop().VisiAble && MapCube[x-1][y].findTop().MoveAble)
                        if(MapCube[x-1][y].findTop().Class=="MoveItem")
                        if(Ap-MapCube[x-1][y].findTop().Under.AP>=0)
                        {
                            path.push(position);
                            short_path(x-1,y,x1,y1,Ap-MapCube[x-1][y].findTop().Under.AP);
                            path.pop();
                        }
                        break;
                    case 1:
                        if(x>=0 && x<Option.CubeX && y-1>=0 && y-1<Option.CubeY)//邊界判定 
                        if(MapCube[x][y-1].findTop().VisiAble && MapCube[x][y-1].findTop().MoveAble)
                        if(MapCube[x][y-1].findTop().Class=="MoveItem")
                        if(Ap-MapCube[x][y-1].findTop().Under.AP>=0 )
                        {
                            path.push(position);
                            short_path(x,y-1,x1,y1,Ap-MapCube[x][y-1].findTop().Under.AP);
                            path.pop();
                        }
                        break;
                    case 2:
                        if(x+1>=0 && x+1<Option.CubeX && y>=0 && y<Option.CubeY)//邊界判定 
                        if(MapCube[x+1][y].findTop().VisiAble && MapCube[x+1][y].findTop().MoveAble)
                        if(MapCube[x+1][y].findTop().Class=="MoveItem")
                        if(Ap-MapCube[x+1][y].findTop().Under.AP>=0 )
                        {
                                           path.push(position);
                            short_path(x+1,y,x1,y1,Ap-MapCube[x+1][y].findTop().Under.AP);
                            path.pop();
                        }
                        break;
                    case 3:
                        if(x>=0 && x<Option.CubeX && y+1>=0 && y+1<Option.CubeY)//邊界判定 
                        if(MapCube[x][y+1].findTop().VisiAble && MapCube[x][y+1].findTop().MoveAble)
                        if(MapCube[x][y+1].findTop().Class=="MoveItem")
                        if(Ap-MapCube[x][y+1].findTop().Under.AP>=0 )
                        {
                                           path.push(position);
                            short_path(x,y+1,x1,y1,Ap-MapCube[x][y+1].findTop().Under.AP);
                            path.pop();
                        }
                        break;
                    default:
                    }
                }
                    }
            }
                    //滑鼠進入、離開顯示
                    tmp.Div.addEventListener('mouseover',function() {
                         for(var j=0;j!=MoveCube.length;j++){
                           if(MoveCube[j].Under.Class=="MapItem")
                                MoveCube[j].Div.style.backgroundColor="#FFFF00";
                            else
                                MoveCube[j].Div.style.backgroundColor=MoveCube[j].Under.Div.style.backgroundColor;
                        }
                        //路徑顯示
              
                        short_path(me.X,me.Y,tmp.X,tmp.Y,me.AP);
                        if(bestcost>=0)
                        for(var j=0;j!=bestpath.length;j++)
                        {
                            if(MapCube[bestpath[j].x][bestpath[j].y].findTop().Class=='MoveItem'){
                            MapCube[bestpath[j].x][bestpath[j].y].findTop().Div.style.backgroundColor='#FF0000';
                            }
                        
                        }
                        while(parent.VARIABLE.View.GameArea.RightControl.button.firstChild) parent.VARIABLE.View.GameArea.RightControl.button.removeChild(parent.VARIABLE.View.GameArea.RightControl.button.firstChild);
                        if(bestcost>=0){
                        parent.VARIABLE.View.GameArea.RightControl.button.appendChild(document.createTextNode("從座標:"+me.X+","+me.Y));
                        parent.VARIABLE.View.GameArea.RightControl.button.appendChild(document.createElement("br"));
                        parent.VARIABLE.View.GameArea.RightControl.button.appendChild(document.createTextNode("移動到座標:"+tmp.X+","+tmp.Y));
                        parent.VARIABLE.View.GameArea.RightControl.button.appendChild(document.createElement("br"));
                        parent.VARIABLE.View.GameArea.RightControl.button.appendChild(document.createTextNode("所需AP:"+(me.AP-bestcost)+"點"));
                        }
                        else
                        parent.VARIABLE.View.GameArea.RightControl.button.appendChild(document.createTextNode("AP點不足"));
                        parent.VARIABLE.View.GameArea.RightControl.button.appendChild(document.createElement("br"));
                        
                    });
                    
                    tmp.Div.addEventListener('click',function(){
                    if(bestcost>=0){
                    for(var j=0;j!=MoveCube.length;j++){
                        MoveCube[j].earse();
                    }
                    //Move_Action(me.X,me.Y,tmp.X,tmp.Y);
                    MapCube[me.X][me.Y].earse(me);
                    me.Move(tmp.X,tmp.Y);
                    //要新增可以躲藏、穿越建築物
                    
                    if(MapCube[tmp.X][tmp.Y].findTop().Class=="BulidingItem")
                       MapCube[tmp.X][tmp.Y].insert(me,MapCube[tmp.X][tmp.Y].findTop());
                    else
                        MapCube[tmp.X][tmp.Y].insert(me);
                    me.AP=bestcost;
                    MoveCube.length=0;
                    rendCube();
                    parent.VARIABLE.View.GameArea.LeftControl.MoveButton.childNodes[0].nodeValue="開始移動";
                    }
                    });
                    
            }());}}
            var CenterX = me.X;
            var CenterY = me.Y;
            var Horizons=me.MoveRange;
            
            for(var x=-Horizons;x<=Horizons;x++)
            {
                var tmp=Horizons-Math.abs(x);
               
                for(var y=-tmp;y<=tmp;y++)
                {
                    if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                    if(MapCube[CenterX+x][CenterY+y].findTop().MoveAble==true) //地形不允許
                    if(MapCube[CenterX+x][CenterY+y].findTop().VisiAble)//超出視野
                    {
                        var Move=new MoveItem(CenterX+x,CenterY+y);
                        MoveCube.push(Move);
                        MapCube[CenterX+x][CenterY+y].insert(Move);
                        Move.Div.style.cursor='pointer';
                    }
                }
            }
            addEvent();
            rendCube();
            
        }
        function MoveCancel(){
            for(var i=0;i!=MoveCube.length;i++){
                MoveCube[i].earse();
            }
            MoveCube.length=0;
            rendCube();
        }
        function Bulid(){
             function addEvent(){
                for(var i=0;i!=BulidCube.length;i++){(function(){
                    var tmp=BulidCube[i];
                    console.log(1);
                    //滑鼠進入、離開顯示
                    tmp.Div.addEventListener('mouseover',function() {
                         for(var j=0;j!=BulidCube.length;j++){
                           if(BulidCube[j].Under.Class=="MapItem")
                                BulidCube[j].Div.style.backgroundColor="#FFFF00";
                            else
                                BulidCube[j].Div.style.backgroundColor=BulidCube[j].Under.Div.style.backgroundColor;
                        }
                        tmp.Div.style.backgroundColor="#FF0000";
                    });
                    
                    tmp.Div.addEventListener('click',function(){
                    
                    for(var j=0;j!=BulidCube.length;j++){
                        BulidCube[j].earse();
                    }
                    var buliding=new BulidingItem(tmp.X,tmp.Y,'HOUSE','A');
                    House.push(buliding);
                    MapCube[tmp.X][tmp.Y].insert(buliding);
                    BulidCube.length=0;
                    rendCube();
                    parent.VARIABLE.View.GameArea.LeftControl.BulidButton.childNodes[0].nodeValue="蓋房子!!";
                    
                    });
                    
            }());}}
            var CenterX = me.X;
            var CenterY = me.Y;
            var Horizons=1;
            for(var x=-Horizons;x<=Horizons;x++)
            {
               
                for(var y=-Horizons;y<=Horizons;y++)
                {
                    if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                    if(MapCube[CenterX+x][CenterY+y].findTop().MoveAble==true) //地形不允許
                    if(MapCube[CenterX+x][CenterY+y].findTop().VisiAble)//超出視野
                    if(MapCube[CenterX+x][CenterY+y].findTop().Class=='MapItem')//只能蓋在地圖上
                    {
                        var tmp=new BulidItem(CenterX+x,CenterY+y);
                        BulidCube.push(tmp);
                        MapCube[CenterX+x][CenterY+y].insert(tmp);
                        tmp.Div.style.cursor='pointer';
                    }
                }
            }
            addEvent();
            rendCube();
        }
        function BulidCancel(){
            for(var i=0;i!=BulidCube.length;i++){
                BulidCube[i].earse();
            }
            BulidCube.length=0;
            rendCube();
        }
        function Attack(){
            //按下移動按鈕後,來放AttackItem
            //在對AttackItem加功能，要刪掉只要把AttackCube清空就行
            //未來可以加範圍攻擊、近戰
            var CenterX = me.X;
            var CenterY = me.Y;
            var Horizons=100;
            for(var x=-Horizons;x<=Horizons;x++)
            {
                var tmp=Horizons-Math.abs(x);
               
                for(var y=-tmp;y<=tmp;y++)
                {
                    if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                    //if(MapCube[CenterX+x][CenterY+y].findTop().VisiAble)//超出視野
                    {
                        var Attack=new AttackItem(CenterX+x,CenterY+y);
                        AttackCube.push(Attack);
                        MapCube[CenterX+x][CenterY+y].insert(Attack);
                        Attack.Div.style.cursor='pointer';
                        
                    }
                }
            }
            addEvent();
            rendCube();
            function addEvent(){//要使用迴圈加eventlistener要這樣寫
                //擴散攻擊測試,
                for(var i=0;i!=AttackCube.length;i++){
                (function(){
                var tmp=AttackCube[i];
                var CenterX = tmp.X;
                var CenterY = tmp.Y;
                var Horizons=10;//要擴散多大,0為1個
                    
                  tmp.Div.addEventListener('mouseover',function() {
                      for(var j=0;j!=AttackCube.length;j++){
                           if(AttackCube[j].Under.Class=="MapItem")
                                AttackCube[j].Div.style.backgroundColor="#FFFF00";
                            else
                            {
                                if(AttackCube[j].Under.VisiAble)
                                    AttackCube[j].Div.style.backgroundColor=AttackCube[j].Under.Div.style.backgroundColor;
                                else
                                    AttackCube[j].Div.style.backgroundColor="#FFFF00";
                            }        
                        }
                      
                    for(var x=-Horizons;x<=Horizons;x++)
                    {
                        var _tmp=Horizons-Math.abs(x);
               
                        for(var y=-_tmp;y<=_tmp;y++)
                        {
                            if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                            if(MapCube[CenterX+x][CenterY+y].findTop().Class=='AttackItem')
                            {
                                  MapCube[CenterX+x][CenterY+y].findTop().Div.style.backgroundColor='#FF0000';
                            }
                        }
                    }});
                    tmp.Div.addEventListener('click',function(){
                    
                    for(var x=-Horizons;x<=Horizons;x++)
                    {
                        var _tmp=Horizons-Math.abs(x);
               
                        for(var y=-_tmp;y<=_tmp;y++)
                        {
                            if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                            if(MapCube[CenterX+x][CenterY+y].findTop().Class=='AttackItem')
                            {
                                MapCube[CenterX+x][CenterY+y].findTop().earse();
                                MapCube[CenterX+x][CenterY+y].findTop().earse();
                            }
                        }
                    }
                    for(var j=0;j!=AttackCube.length;j++)
                        AttackCube[j].earse();
                    AttackCube.length=0;
                    View();
                    rendCube();
                    parent.VARIABLE.View.GameArea.LeftControl.AttackButton.childNodes[0].nodeValue="開始攻擊"; },false);
                }());
                
            }
            }
        }
        function AttackCancel(){
            for(var i=0;i!=AttackCube.length;i++)
                AttackCube[i].earse();
            AttackCube.length=0;
            rendCube();
        }
        function Paint(input){
            var CenterX = 0;
            var CenterY = 0;
            var Horizons=100;
            for(var x=-Horizons;x<=Horizons;x++)
            {
                var tmp=Horizons-Math.abs(x);
               
                for(var y=-tmp;y<=tmp;y++)
                {
                    if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                    {
                        var Attack=new AttackItem(CenterX+x,CenterY+y);
                        AttackCube.push(Attack);
                        MapCube[CenterX+x][CenterY+y].insert(Attack);
                        Attack.Div.style.cursor='pointer';
                        
                    }
                }
            }
            Horizons=0;//要擴散多大,0為1個
            addEvent(input);
            rendCube();
            function addEvent(input){//要使用迴圈加eventlistener要這樣寫
                //擴散攻擊測試,
                for(var i=0;i!=AttackCube.length;i++){
                (function(){
                var tmp=AttackCube[i];
                var CenterX = tmp.X;
                var CenterY = tmp.Y;
                
                
                tmp.Div.addEventListener('dblclick',function() {
                    Horizons++;
                });
                  tmp.Div.addEventListener('mouseover',function() {
                      for(var j=0;j!=AttackCube.length;j++){
                            AttackCube[j].Div.style.backgroundColor=AttackCube[j].Under.Div.style.backgroundColor;
                }        
                        
                      
                    for(var x=-Horizons;x<=Horizons;x++)
                    {
                        var _tmp=Horizons-Math.abs(x);
               
                        for(var y=-_tmp;y<=_tmp;y++)
                        {
                            if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                            if(MapCube[CenterX+x][CenterY+y].findTop().Class=='AttackItem')
                            {
                                  MapCube[CenterX+x][CenterY+y].findTop().Div.style.backgroundColor='#FF0000';
                            }
                        }
                    }});
                    tmp.Div.addEventListener('click',function(){
                    
                    for(var x=-Horizons;x<=Horizons;x++)
                    {
                        var _tmp=Horizons-Math.abs(x);
               
                        for(var y=-_tmp;y<=_tmp;y++)
                        {
                            if(CenterX+x>=0 && CenterX+x<Option.CubeX && CenterY+y>=0 && CenterY+y<Option.CubeY)//邊界判定 
                            if(MapCube[CenterX+x][CenterY+y].findTop().Class=='AttackItem')
                            {
                                
                                //MapCube[CenterX+x][CenterY+y].findTop().earse();
                                MapCube[CenterX+x][CenterY+y].Type=input;
                            }
                        }
                    }
                    
                    rendCube();
                    //parent.VARIABLE.View.GameArea.LeftControl.AttackButton.childNodes[0].nodeValue="開始攻擊";
                    },false);
                }());
                
            }
            }
        }
        function Stay() {
            parent.resetButton();
            //me.AP+=10;
            UpLoad();
            //Turn++;
            //View();
            //rendCube();
        }
        function UpLoad(){
            var updata = new Object();
            updata.House = [];
            updata.Player = [];
            updata.Map=[];
            for(var i=0;i<Option.CubeX;i++){
                for(var j=0;j<Option.CubeY;j++){
                    updata.Map.push(MapCube[i][j].getData());
                    //console.log(MapCube[i][j].getData());
                }
            }
            /*
            for(var i=0;i!=House.length;i++)
            {
                updata.House.push(House[i].getData());
            }
            for(var i=0;i!=player.length;i++)
            {
                updata.Player.push(player[i].getData());
            }
            */
            var data=JSON.stringify(updata);
            saveTextAsFile('Map',data);
            
            //最後在json
            /*global sendGameCommand 實作於ajax*/
            sendGameCommand(JSON.stringify(updata));
        }//上傳資料
        
        function saveTextAsFile( _fileName, _text ) {
            var textFileAsBlob = new Blob([_text], {type:'text/plain'});
 
            var downloadLink = document.createElement("a");
            downloadLink.download = _fileName;
            downloadLink.innerHTML = "Download File";
            if (window.webkitURL != null) {
            // Chrome allows the link to be clicked
            // without actually adding it to the DOM.
                downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
            } else {
          // Firefox requires the link to be added to the DOM
             // before it can be clicked.
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.onclick = destroyClickedElement;
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
         }
 
        downloadLink.click();
        }
        function destroyClickedElement(event) {
            document.body.removeChild(event.target);
        }
</script>


</html>
